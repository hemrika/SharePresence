// -----------------------------------------------------------------------
// <copyright file="Option.cs" company="">
// TODO: Update copyright text.
// </copyright>
// -----------------------------------------------------------------------

namespace Hemrika.SharePresence.Extensions
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using System.Runtime.Serialization;

    public static class Option
    {
        /// <summary>
        /// Create a <c>Some</c> based on the given <paramref name="value"/>.
        /// </summary>
        public static Option<TValue> Some<TValue>(TValue value)
        {
            return new Option<TValue>(value);
        }

        /// <summary>
        /// Create a <c>None</c> for the given type <typeparamref name="TValue"/>.
        /// </summary>
        public static Option<TValue> None<TValue>()
        {
            return Option<TValue>.None;
        }

        /// <summary>
        /// Return the value of a <c>Some</c> or throw an exception returned from the function <paramref name="efunc"/>.
        /// </summary>
        public static T Value<T>(this Option<T> option, Func<Exception> efunc)
        {
            if (option.IsNone)
            {
                throw efunc();
            }

            return option.Value;
        }

        /// <summary>
        /// Return the value of a <c>Some</c> or in the case of <c>None</c> a default value generated by the function <paramref name="default"/>.
        /// </summary>
        public static T Value<T>(this Option<T> a, Func<T> @default)
        {
            return a.IsSome ? a.Value : @default();
        }

        /// <summary>
        /// Create an <see cref="IEnumerable{T}"/> from an Option. A <c>None</c> yields an empty enumerable, a <c>Some</c> yields a enumeration
        /// with the single value.
        /// </summary>
        public static IEnumerable<T> ToEnumerable<T>(this Option<T> a)
        {
            if (a.IsSome) { yield return a.Value; }
        }

        /// <summary>
        /// Return the value of a <c>Some</c> or in the case of <c>None</c> <c>null</c>.
        /// </summary>
        public static T NullableValue<T>(this Option<T> a) where T : class
        {
            return a.IsNone ? null : a.Value;
        }

        /// <summary>
        /// Return the value of a <c>Some</c> or in the case of <c>None</c> the default value <paramref name="default"/>.
        /// </summary>
        public static T Value<T>(this Option<T> a, T @default)
        {
            return a.IsSome ? a.Value : @default;
        }

        /// <summary>
        /// Return the value of a <c>Some</c> or in the case of <c>None</c> the default value of the type <typeparamref name="T"/>.
        /// </summary>
        public static T ValueOrDefault<T>(this Option<T> a)
        {
            return a.Value(default(T));
        }

        /// <summary>
        /// Return the result of applying the value of a <c>Some</c> to the function <paramref name="fn"/> or in the case of
        /// a <c>None</c> the default value generated from the function <paramref name="default"/>.
        /// </summary>
        public static TResult SelectValue<T, TResult>(this Option<T> a, Func<T, TResult> fn, Func<TResult> @default)
        {
            return a.IsSome ? fn(a.Value) : @default();
        }

        /// <summary>
        /// Return the result of applying the value of a <c>Some</c> to the function <paramref name="fn"/> or in the case of
        /// a <c>None</c> the default value <paramref name="default"/>.
        /// </summary>
        public static TResult SelectValue<T, TResult>(this Option<T> a, Func<T, TResult> fn, TResult @default)
        {
            return a.IsSome ? fn(a.Value) : @default;
        }

        /// <summary>
        /// Convert <see cref="Option{T}"/> to an <see cref="Nullable{T}"/>.
        /// </summary>
        public static T? ToNullable<T>(this Option<T> a) where T : struct
        {
            if (a.IsSome)
            {
                return new Nullable<T>(a.Value);
            }
            return new Nullable<T>();
        }

        /// <summary>
        /// Convert a <see cref="Nullable{T}"/> value object to an option where null yields to <c>None</c> and any
        /// other value to <c>Some(value)</c>.
        /// </summary>
        public static Option<T> ToOption<T>(this Nullable<T> a) where T : struct
        {
            if (!a.HasValue)
            {
                return Option.None<T>();
            }
            return a.Value.ToOption();
        }

        /// <summary>
        /// Convert a reference object to an option where null yields to <c>None</c> and any
        /// other value to <c>Some(value)</c>.
        /// </summary>
        public static Option<T> ToOption<T>(this T a)
        {
            if (ReferenceEquals(null, a))
            {
                return Option.None<T>();
            }
            return Option.Some(a);
        }

        /// <summary>
        /// Convert an enumerable to an <see cref="Option{T}"/>. The result will be a <c>Some</c> with the first element of the
        /// enumerable or a <c>None</c> if the enumerable is empty.
        /// </summary>
        public static Option<T> ToOptionFromEnumerable<T>(this IEnumerable<T> xs)
        {
            foreach (var x in xs)
            {
                return x.ToOption();
            }

            return Option.None<T>();
        }

        /// <summary>
        /// Try to cast an object to an <see cref="Option{T}"/> some. If the cast fails, a <c>None</c> is yield.
        /// </summary>
        public static Option<T> Cast<T>(this object a)
        {
            try
            {
                var t = (T)a;
                return t.ToOption();
            }
            catch
            {
                return Option.None<T>();
            }
        }

        /// <summary>
        /// Execute the side effect <paramref name="action"/> with the value of the <c>Some</c> or do nothing.
        /// </summary>
        public static void Run<T>(this Option<T> a, Action<T> action)
        {
            if (a.IsSome)
            {
                action(a.Value);
            }
        }

        /// <summary>
        /// Excecute the side effect <paramref name="action"/> with the value of a <c>Some</c> or throw an
        /// exception (either <paramref name="e"/> or <see cref="InvalidOperationException"/>)
        /// </summary>
        public static void RunOrThrow<T>(this Option<T> a, Action<T> action, Exception e = null)
        {
            if (a.IsNone)
            {
                throw e ?? new InvalidOperationException("RunOrThrow: Option.None can not be run.");
            }

            action(a.Value);
        }

        /// <summary>
        /// Execute the side effect <paramref name="action"/> if the value in the <c>Some</c> of type <c>bool</c> is
        /// <c>true</c>. Otherwise nothing is done.
        /// </summary>
        public static void RunWhenTrue(this Option<bool> a, Action action)
        {
            if (a.IsSome && a.Value)
            {
                action();
            }
        }

        /// <summary>
        /// Reduce/Collapse a nested <see cref="Option{T}"/>.
        /// </summary>
        public static Option<T> Collapse<T>(this Option<Option<T>> t)
        {
            if (t.IsNone || t.Value.IsNone)
            {
                return Option.None<T>();
            }
            return t.Value;
        }

        /// <summary>
        /// Return <paramref name="a"/> if it is a <c>Some</c>, else return a <c>Some</c> with the value of <paramref name="b"/>.
        /// </summary>
        public static Option<T> Or<T>(this Option<T> a, T b)
        {
            return a.IsSome ? a : b.ToOption();
        }

        /// <summary>
        /// Return <paramref name="a"/> if it is a <c>Some</c>, else return a <c>Some</c> with the return value of the function <paramref name="b"/>.
        /// </summary>
        public static Option<T> Or<T>(this Option<T> a, Func<Option<T>> b)
        {
            return a.IsSome ? a : b();
        }

        /// <summary>
        /// Return <paramref name="a"/> if it is a <c>Some</c>, else return <paramref name="b"/>.
        /// </summary>
        public static Option<T> Or<T>(this Option<T> a, Option<T> b)
        {
            return a.IsSome ? a : b;
        }

        /// <summary>
        /// Return a new <c>Some</c> containing the transformed value of <paramref name="a"/>. If <paramref name="a"/> is a
        /// <c>None</c>, a <c>None</c> will be returned. The function <paramref name="func"/> will be used to transform a
        /// <c>Some</c>.
        /// </summary>
        public static Option<TResult> Select<T, TResult>(this Option<T> a, Func<T, TResult> func)
        {
            return a.IsSome ? new Option<TResult>(func(a.Value)) : Option.None<TResult>();
        }

        /// <summary>
        /// Apply the <paramref name="selector"/> to every option in the given enumerable <paramref name="options"/>.
        /// </summary>
        public static IEnumerable<Option<TResult>> Select<T, TResult>(this IEnumerable<Option<T>> options, Func<T, TResult> selector)
        {
            return options.Select(option => option.Select(selector));
        }

        /// <summary>
        /// Return an enumerable containing only the <c>Some</c>'s of the given <paramref name="options"/>.
        /// </summary>
        public static IEnumerable<T> SelectValid<T>(this IEnumerable<Option<T>> options)
        {
            return SelectValid(options, m => m);
        }

        /// <summary>
        /// Return an enumerable containing only the with the function <paramref name="func"/> transformed <c>Some</c>'s of the
        /// given <paramref name="options"/>.
        /// </summary>
        public static IEnumerable<TResult> SelectValid<T, TResult>(this IEnumerable<Option<T>> options, Func<T, TResult> func)
        {
            return from option in options
                   where option.IsSome
                   select func(option.Value);
        }

        /// <summary>
        /// Filter an enumerable <paramref name="xs"/> of values with the predicate function <paramref name="pred"/>.
        /// If <paramref name="pred"/> returns <c>None</c>, the result of <see cref="WhereOption{T}"/> will also be <c>None</c>.
        /// Else the boolean value inside the <c>Some</c> returned by the predicate function <paramref name="pred"/> will be used
        /// to filter the values in <paramref name="xs"/>. Only values for which the predicate returns <c>true</c> are then
        /// included in the resulting enumeration.
        /// </summary>
        public static Option<IEnumerable<T>> WhereOption<T>(this IEnumerable<T> xs, Func<T, Option<bool>> pred)
        {
            var l = new List<T>();
            foreach (var x in xs)
            {
                var r = pred(x);
                if (r.IsNone)
                {
                    return Option.None<IEnumerable<T>>();
                }
                if (r.Value)
                {
                    l.Add(x);
                }
            }
            return Option.Some<IEnumerable<T>>(l);
        }

        /// <summary>
        /// Filter a single <see cref="Option"/>. <see cref="Where"/> returns <c>None</c> if either <paramref name="a"/> is None or
        /// <paramref name="pred"/> return <c>false</c>. Otherwise <paramref name="a"/> is returned.
        /// </summary>
        public static Option<T> Where<T>(this Option<T> a, Func<T, bool> pred)
        {
            if (a.IsSome && pred(a.Value))
            {
                return a;
            }
            return Option.None<T>();
        }

        /// <summary>
        /// Project the value in the monadic option context (monadic bind operation).
        /// Note: Needed for LINQ syntax
        /// </summary>
        public static Option<TResult> SelectMany<T, TResult>(this Option<T> a, Func<T, Option<TResult>> selector)
        {
            return a.IsNone ? Option.None<TResult>() : selector(a.Value);
        }

        /// <summary>
        /// Special version of a monadic bind for performance reasons. It combines SelectMany (monadic bind) with ToOption (monadic unit),
        /// so that lambdas are not deeply nested.
        /// Note: Needed for LINQ syntax
        /// </summary>
        public static Option<TResult> SelectMany<T, TOption, TResult>(this Option<T> a, Func<T, Option<TOption>> optionSelector, Func<T, TOption, TResult> resultSelector)
        {
            return a.SelectMany(x => optionSelector(x).SelectMany(y => resultSelector(x, y).ToOption()));
        }

        /// <summary>
        /// Turn a enumeration of <c>Some</c>'s into a <c>Some</c> containing an enumeration of the <c>Some</c>'s values. If the
        /// enumeration <paramref name="options"/> contains a <c>None</c>, <see cref="Sequence{T}"/> will also
        /// return a <c>None</c>.
        /// </summary>
        public static Option<IEnumerable<T>> Sequence<T>(this IEnumerable<Option<T>> options)
        {
            var list = new List<T>();
            foreach (var option in options)
            {
                if (option.IsNone)
                {
                    return Option.None<IEnumerable<T>>();
                }
                list.Add(option.Value);
            }

            return Option.Some<IEnumerable<T>>(list);
        }
    }
    [Serializable]
    public class OptionValueAccessException : Exception
    {
        public OptionValueAccessException() { }
        public OptionValueAccessException(string message) : base(message) { }
        public OptionValueAccessException(string message, Exception innerException) : base(message, innerException) { }
        protected OptionValueAccessException(SerializationInfo info, StreamingContext context) : base(info, context) { }
    }

    [Serializable]
    public class SomeInitializedWithNullException : Exception
    {
        public SomeInitializedWithNullException() { }
        public SomeInitializedWithNullException(string message) : base(message) { }
        public SomeInitializedWithNullException(string message, Exception innerException) : base(message, innerException) { }
        protected SomeInitializedWithNullException(SerializationInfo info, StreamingContext context) : base(info, context) { }
    }

    /// <summary>
    /// Optional type, which represents either the existence (<c>Some</c>) of a value and the value itself or the
    /// absence (<c>None</c>) of a value.
    /// <para>
    ///   Decision: Option{T} is a struct, so it never can be set to <c>null</c>. Ergo a method returning an Option{T} can
    ///   never return <c>null</c>.
    /// </para>
    /// <para>
    ///   Options should _not_ be created with the Constructors. Instead us one of:
    ///   <list type="bullet">
    ///     <item><description><see cref="Option.Some{TValue}"/></description></item>
    ///     <item><description><see cref="Option.None{TValue}"/></description></item>
    ///     <item><description><see cref="Option.ToOption{T}(System.Nullable{T})"/></description></item>
    ///   </list>
    ///   (Problem is that the constructors of structs can not be made protected or private.)
    /// </para>
    /// </summary>
    /// <typeparam name="T">Type of the contained value.</typeparam>
    public struct Option<T> : IEquatable<Option<T>>
    {
        private readonly bool _hasValue;
        private readonly T _value;

        /// <summary>
        /// None for the type {T}.
        /// </summary>
        public static readonly Option<T> None = new Option<T>();

        /// <summary>
        /// Don't use!
        /// </summary>
        public Option(T value)
        {
            if (Equals(value, null))
            {
                throw new SomeInitializedWithNullException("Option.Some can not contain null.");
            }
            _hasValue = true;
            _value = value;
        }

        /// <summary>
        /// <c>true</c> if the option is a <c>Some</c> and contains a value.
        /// </summary>
        public bool IsSome { get { return _hasValue; } }

        /// <summary>
        /// <c>true</c> if the option is a <c>None</c> and does _not_ contain a value.
        /// </summary>
        public bool IsNone { get { return !IsSome; } }

        /// <summary>
        /// The value of a <c>Some</c>.
        /// <para>Throws an exception on a <c>None</c>. Don't catch this exception!</para>
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1065:DoNotRaiseExceptionsInUnexpectedLocations")]
        public T Value
        {
            get
            {
                if (_hasValue)
                {
                    return _value;
                }
                throw new OptionValueAccessException("Option.None has no value.");
            }
        }

        public override string ToString()
        {
            return _hasValue ? string.Format("Some({0})", Value) : string.Format("None()");
        }

        public bool Equals(Option<T> other)
        {
            return other._hasValue.Equals(_hasValue) && Equals(other._value, _value);
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (obj.GetType() != typeof(Option<T>)) return false;
            return Equals((Option<T>)obj);
        }

        public override int GetHashCode()
        {
            unchecked
            {
                return (_hasValue.GetHashCode() * 397) ^ _value.GetHashCode();
            }
        }

        public static bool operator ==(Option<T> left, Option<T> right)
        {
            return left.Equals(right);
        }

        public static bool operator !=(Option<T> left, Option<T> right)
        {
            return !left.Equals(right);
        }

        internal object SingleOrDefault()
        {
            throw new NotImplementedException();
        }
    }
}
